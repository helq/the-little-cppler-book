-- app/runcppcode.hs
{-# LANGUAGE LambdaCase #-}

import Text.Pandoc.JSON (toJSONFilter)
import Text.Pandoc (Block(CodeBlock))
import System.Directory (getCurrentDirectory)
import System.FilePath ((</>),(<.>))
import System.IO (hPutStrLn, stderr)
import Data.Maybe (fromMaybe)
import Development.Shake (shake, shakeOptions, shakeVerbosity, Rules, Stdout(Stdout), Stderr(Stderr),
                          Verbosity(Silent), want, (%>), need, cmd, writeFile')
import Development.Shake.FilePath ((-<.>), exe)
import Data.Monoid ((<>))
import System.Environment (getArgs)
import Control.Monad.IO.Class (liftIO)

doInclude :: String -> Block -> IO Block
doInclude currentDir cb@(CodeBlock (_, _, namevals) contents) =
  case lookup "layout" namevals of
       Just f -> do
         file_layout <- readFile $ currentDir </> "code" </> "layouts" </> f
         let newcontent = unlines . fmap insertContent . lines $ file_layout
             num_id = fromMaybe "999" $ lookup "numid" namevals
             cpp_name = num_id <> "-code-autogenerated.cc"

         shake shakeOptions{shakeVerbosity=Silent} $
           compile (currentDir </> "code" </> cpp_name) newcontent

         return cb
       Nothing -> return cb

  where
    contents' = lines contents
    (includes, mainbody) = if "..." `elem` contents'
                              then let (ics, mainc) = break ("..."==) contents'
                                    in (ics, tail mainc)
                              else ([], contents')

    insertContent line = case break (/= ' ') line of
                           -- TODO: modify so unlines doesn't put a newline at the end of the last line
                           (spaces, "---<<<") -> unlines $ fmap (spaces++) includes
                           (spaces, "===<<<") -> unlines $ fmap (spaces++) mainbody
                           _                  -> line

doInclude _ x = return x

compile :: FilePath -> String -> Rules ()
compile cpp_name content = do
  let cpp_out = cpp_name -<.> "out"
  --liftIO . hPutStrLn stderr $ normalise cpp_name
  --liftIO $ hPutStrLn stderr cpp_bin
  want [cpp_name, cpp_out]

  "code/*.out" %> \out -> do
    let bin = out -<.> "bin" <.> exe
    need [bin]
    (Stdout output) <- cmd [bin]
    writeFile' out output

  "code/*.cc" %> \out ->
    writeFile' out content

  ("code/*.bin" <.> exe) %> \out -> do
    let incpp = out -<.> "cc"
    --liftIO . hPutStrLn stderr $ "HEY!"
    need [incpp]
    (Stdout output, Stderr errput) <- cmd "clang++" [incpp] ["-o", out]
    liftIO . hPutStrLn stderr $ output <> "\n" <> errput


main :: IO ()
main = do
  currentDir <- getArgs >>= \case
                               (dir:_) -> pure dir
                               _       -> getCurrentDirectory

  --print currentDir
  toJSONFilter (doInclude currentDir)
